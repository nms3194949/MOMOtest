<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>MOMO雙贏策略｜月配息 × 資產增值 × 智能決策</title>
<style>
:root{--deep:#0A1221;--gold:#C9A227;--gold-soft:#E9D18A;--card:#0F1830;--pos:#39C27A;--neg:#E25A5A;--input:#071226;}
html,body{margin:0;background:var(--deep);color:#fff;font-family:"Noto Sans TC","PingFang TC","Microsoft JhengHei",system-ui,sans-serif}
.wrap{max-width:980px;margin:0 auto;padding:12px 12px 84px}
.table-wrap{overflow-x:auto;-webkit-overflow-scrolling:touch;border:1px solid rgba(201,162,39,.25);border-radius:10px;background:#0C152A;padding:8px}
.table-grid{width:100%;border-collapse:collapse}
.table-grid th,.table-grid td{padding:6px 8px;text-align:left;border:1px solid rgba(233,209,138,.12);font-size:13px}
.debug-table th{background:rgba(201,162,39,.12);color:#E9D18A}
.debug-area{margin-top:18px;border-radius:10px;padding:10px;background:#0f1830;border:1px solid rgba(201,162,39,.18)}
.debug-toggle{background:#18314a;border:1px solid rgba(201,162,39,.25);padding:8px;border-radius:8px;color:var(--gold-soft);cursor:pointer}
.small{font-size:13px;color:#b9c2d5}
.note{color:#b9c2d5;font-size:12px;margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <!-- 省略：保留你原本的整個頁面上方內容 (tabs, forms, ai card, etc.)
       為節省篇幅，我假設你會把本段插入原檔頭部與中段無變動 -->
  <!-- === 這裡請保留你原本完整頁面內容 === -->

  <!-- 我在頁面底部新增 debug 區塊 -->
  <div id="corrDebugArea" class="debug-area" aria-live="polite" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <strong style="color:var(--gold)">相關係數讀取檢查 (Debug)</strong>
        <div class="small">顯示匯入後解析的 1Y / 3Y / 5Y 相關係數矩陣（正規化名稱與原始值），協助確認名稱匹配與分頁解析情況。</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnHideDebug" class="debug-toggle">隱藏</button>
        <button id="btnRefreshDebug" class="debug-toggle">重新渲染</button>
      </div>
    </div>

    <div id="corrDebugSummary" style="margin-top:8px" class="small"></div>

    <div style="margin-top:12px">
      <div style="margin-bottom:8px"><strong style="color:var(--gold)">1Y（近1年）</strong></div>
      <div id="corrTable1" class="table-wrap"></div>
    </div>

    <div style="margin-top:12px">
      <div style="margin-bottom:8px"><strong style="color:var(--gold)">3Y（近3年）</strong></div>
      <div id="corrTable3" class="table-wrap"></div>
    </div>

    <div style="margin-top:12px">
      <div style="margin-bottom:8px"><strong style="color:var(--gold)">5Y（近5年）</strong></div>
      <div id="corrTable5" class="table-wrap"></div>
    </div>

    <div style="margin-top:12px">
      <div><strong style="color:var(--gold)">未匹配或可能問題項（示例：清單內基金在相關係數表沒找到配對）</strong></div>
      <div id="corrUnmatched" class="table-wrap small" style="margin-top:8px"></div>
    </div>
    <p class="note">提示：若你看到某對應的 ρ 值存在於表格內但在主頁顯示為 0 或空，請比對左上方「正規化名稱」欄位的字串（上方表格的欄/列名稱），那通常就是名稱微差或被過濾的原因。</p>
  </div>

  <!-- 你原本頁面其餘內容... -->
</div>

<!-- 引入 xlsx 與 html2canvas（如你原本有） -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* =================== 新增變數：儲存三期 rho maps =================== */
let RHO_1Y = {}, RHO_3Y = {}, RHO_5Y = {};
let RHO_COVERED = new Set(); // 解析後發現的正規化名稱集合
const LS_CORR_KEY = 'momo_corr_matrix_csv_v1'; // 與你原本 key 保持相容

/* =================== 名稱正規化（強化版） =================== */
function normalizeName(s){
  if(!s) return '';
  const toHalf = (str)=>String(str)
    .replace(/\u00A0/g,' ')
    .replace(/[！-～]/g,c=>String.fromCharCode(c.charCodeAt(0)-0xFEE0))
    .replace(/　/g,' ');
  let t = toHalf(String(s)).toLowerCase();
  t = t.replace(/\s+/g,''); // 移除所有空白
  t = t.replace(/[()（）［］【】\[\]·・．\.，,、‧\/\\\-\+～~:：;；!！?？'"“”‘’]/g,''); // 去標點
  t = t.replace(/美元/g,'');
  t = t.replace(/總報酬穩定配息|月配息|累積|配息/g,'');
  t = t.trim();
  return t;
}

/* =================== 解析 XLSX workbook（支援三分頁：1Y/3Y/5Y） =================== */
function parseCorrWorkbookToRhoMaps(workbook){
  // 定義可能的分頁別名（可再擴充）
  const want = [
    {key:'rho_1y', aliases:['1y','1yr','1年','近1年','1-year','1 yr','1y相關']},
    {key:'rho_3y', aliases:['3y','3yr','3年','近3年','3-year','3 yr','3y相關']},
    {key:'rho_5y', aliases:['5y','5yr','5年','近5年','5-year','5 yr','5y相關']},
  ];
  const out = {rho_1y:{}, rho_3y:{}, rho_5y:{}, covered:new Set(), sheetMatched:[]};

  function sheetNameLike(name,aliases){
    if(!name) return false;
    const n = normalizeName(name);
    for(const a of aliases){
      if(normalizeName(a) === n) return true;
      if(n.includes(normalizeName(a))) return true;
    }
    return false;
  }

  for(const wsName of workbook.SheetNames){
    const ws = workbook.Sheets[wsName];
    // 嘗試判斷是哪一期
    let target = want.find(w => sheetNameLike(wsName, w.aliases));
    // 如果沒自動命中，允許使用 '1','3','5' 的關鍵字或含 year
    if(!target){
      const ln = wsName.toLowerCase();
      if(ln.includes('1') && ln.includes('y')) target = want[0];
      if(ln.includes('3') && ln.includes('y')) target = want[1];
      if(ln.includes('5') && ln.includes('y')) target = want[2];
    }
    if(!target) {
      // 若還沒命中，嘗試讀第一列看看是否有 "1Y"/"3Y" 等字樣
      // 若沒找到，我們仍嘗試用檔案中所有 sheet 解析，但不放到特定期別（避免漏掉）
      // 這裡預設：若 sheet 名稱無法辨識我們將嘗試把它當作 3Y（保守）
      target = want[1]; // default to 3y
    }

    // 讀取 sheet 為矩陣
    const rows = XLSX.utils.sheet_to_json(ws, {header:1, defval:''});
    if(!rows || rows.length < 2) continue;

    // header（第一列）為基金欄名（第 0 欄通常為空或列名）
    const headerRaw = rows[0].slice(1).map(x=>String(x||'').trim());
    const headerNormalized = headerRaw.map(x=>normalizeName(x));

    for(let i=1;i<rows.length;i++){
      const row = rows[i];
      if(!row || row.length < 2) continue;
      const rawRowName = String(row[0]||'').trim();
      const rowName = normalizeName(rawRowName);
      if(!rowName) continue;
      for(let j=1;j<row.length;j++){
        const rawColName = headerRaw[j-1]||'';
        const colName = headerNormalized[j-1]||'';
        if(!colName) continue;

        let v = row[j];
        if(typeof v === 'string') v = v.replace(/,/g,'').trim();
        v = Number(v);
        if(!Number.isFinite(v)) continue; // skip non-numeric cells

        // clamp -1..1
        v = Math.max(-1, Math.min(1, v));

        const key = [rowName, colName].sort().join('|');
        out[target.key][key] = v;
        out.covered.add(rowName);
        out.covered.add(colName);
      }
    }

    out.sheetMatched.push(wsName);
  }

  return out;
}

/* =================== 匯入相關係數檔案（覆蓋原匯入流程） =================== */
document.addEventListener('DOMContentLoaded',()=>{ // 先綁在 DOMContentLoaded，避免找不到元素
  const proFileEl = document.getElementById('pro_corr_file');
  if(proFileEl){
    proFileEl.addEventListener('change',(e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      importCorrFileMultiSheet(f);
      e.target.value='';
    });
  }
  const importBtn = document.getElementById('pro_corr_import_btn');
  if(importBtn){
    importBtn.addEventListener('click',()=>{ if(proFileEl) proFileEl.click(); });
  }
});

function importCorrFileMultiSheet(file){
  const ext = (file.name.split('.').pop()||'').toLowerCase();
  const fr = new FileReader();
  fr.onload = (evt)=>{
    try{
      if(ext==='xlsx' || ext==='xls'){
        const wb = XLSX.read(evt.target.result, {type:'array'});
        const parsed = parseCorrWorkbookToRhoMaps(wb);

        // 分別掛到全域變數
        RHO_1Y = parsed.rho_1y || {};
        RHO_3Y = parsed.rho_3y || {};
        RHO_5Y = parsed.rho_5y || {};
        RHO_COVERED = parsed.covered || new Set();

        // 為相容性：也把原始 CSV 文字存起來（方便你現有邏輯讀取）
        const csvText = generateCsvFromRhoMaps(RHO_1Y, RHO_3Y, RHO_5Y);
        localStorage.setItem(LS_CORR_KEY, csvText);

        updateCorrStatusIndicator(); // 更新 UI 燈號
        renderDebugTables(); // 自動顯示 debug 區塊與表格
        proScheduleRun(true); // 觸發最佳化運算
        alert('已載入相關係數檔（支援 1Y/3Y/5Y 三分頁）。');
      } else {
        // 若是 CSV/TXT 則維持原有行為（舊流程）
        // 轉成文字並存入 localStorage
        const txt = new TextDecoder('utf-8').decode(evt.target.result);
        localStorage.setItem(LS_CORR_KEY, txt);
        // 嘗試用原本解析函式（若你原本有）
        // 這裡還是嘗試解析成 3Y（fallback）
        RHO_1Y = {}; RHO_3Y = {}; RHO_5Y = {}; RHO_COVERED = new Set();
        // call existing parseCorrMatrix if present
        if(typeof parseCorrMatrix === 'function'){
          const parsed = parseCorrMatrix(txt);
          // parsed.rho => map, parsed.names...
          // 放到 3Y 作為預設
          RHO_3Y = parsed.rho || {};
          parsed.covered && parsed.covered.forEach(x=>RHO_COVERED.add(x));
          renderDebugTables();
        } else {
          alert('已儲存 CSV，但無法自動轉成 1/3/5 年矩陣（請匯入 xlsx）。');
        }
        updateCorrStatusIndicator();
        proScheduleRun(true);
      }
    }catch(err){
      console.error(err);
      alert('匯入相關係數失敗：'+err.message);
    }
  };
  fr.readAsArrayBuffer(file);
}

/* 將三個 rhoMap 轉成簡單 CSV（方便儲存與相容） */
function generateCsvFromRhoMaps(r1,r3,r5){
  // 簡單將三 map 轉成可存取的文本（每一對以 key,value 格式存在），便於原有邏輯載入
  const rows = [];
  const collectPairs = (m, tag) => {
    for(const k in m) rows.push([tag, k, m[k]]);
  };
  collectPairs(r1,'1Y'); collectPairs(r3,'3Y'); collectPairs(r5,'5Y');
  return rows.map(r=>r.join('\t')).join('\n');
}

/* =================== 取得對應期別的 rhoMap =================== */
function pickRhoMapByMode(mode){
  mode = String(mode||'3y').toLowerCase();
  if(mode.startsWith('1')) return RHO_1Y;
  if(mode.startsWith('5')) return RHO_5Y;
  return RHO_3Y;
}

/* =================== 在頁面顯示 debug tables =================== */
function renderDebugTables(){
  const area = document.getElementById('corrDebugArea');
  area.style.display = 'block';
  const s1 = document.getElementById('corrTable1');
  const s3 = document.getElementById('corrTable3');
  const s5 = document.getElementById('corrTable5');
  const sum = document.getElementById('corrDebugSummary');
  const um = document.getElementById('corrUnmatched');

  s1.innerHTML = renderRhoMapTableHtml(RHO_1Y, '1Y');
  s3.innerHTML = renderRhoMapTableHtml(RHO_3Y, '3Y');
  s5.innerHTML = renderRhoMapTableHtml(RHO_5Y, '5Y');

  // summary
  const keys1 = Object.keys(RHO_1Y||{}).length;
  const keys3 = Object.keys(RHO_3Y||{}).length;
  const keys5 = Object.keys(RHO_5Y||{}).length;
  sum.innerHTML = `<span class="small">解析到的 pair 數 — 1Y: ${keys1}, 3Y: ${keys3}, 5Y: ${keys5}。已登錄之正規化名稱數：${RHO_COVERED.size||0}。</span>`;

  // 未匹配：把基金清單中出現但在 rho map 未出現的顯示（如果你有基金清單/表格可放到檢查）
  // 這裡示例顯示 RHO_COVERED 集合（若你有來源/投組清單，可與之比對）
  let outHtml = `<div class="small">已解析的正規化名稱 (範例 ${Math.min(200,RHO_COVERED.size)} 個)：</div>`;
  outHtml += `<div style="max-height:240px;overflow:auto;margin-top:6px"><table class="table-grid debug-table"><thead><tr><th>正規化名稱</th></tr></thead><tbody>`;
  Array.from(RHO_COVERED).slice(0,100).forEach(n=>{ outHtml += `<tr><td>${n}</td></tr>`; });
  outHtml += `</tbody></table></div>`;
  um.innerHTML = outHtml;
}

/* render single rho map -> HTML table（以鍵名分解為 row/col） */
function renderRhoMapTableHtml(rhoMap, tag){
  if(!rhoMap || Object.keys(rhoMap).length===0) return '<div class="small">無資料</div>';
  // reconstruct set of names
  const nameSet = new Set();
  for(const k in rhoMap){
    const parts = k.split('|');
    if(parts[0]) nameSet.add(parts[0]);
    if(parts[1]) nameSet.add(parts[1]);
  }
  const names = Array.from(nameSet).sort();
  // header
  let html = '<table class="table-grid debug-table"><thead><tr><th></th>';
  names.forEach(n=> html += `<th>${n}</th>`);
  html += '</tr></thead><tbody>';
  // rows
  names.forEach(rn=>{
    html += `<tr><th>${rn}</th>`;
    names.forEach(cn=>{
      const key=[rn,cn].sort().join('|');
      const v = Object.prototype.hasOwnProperty.call(rhoMap, key) ? rhoMap[key] : '';
      html += `<td>${v === '' ? '—' : (Math.abs(v)===1 ? v.toFixed(0) : v.toFixed(6))}</td>`;
    });
    html += '</tr>';
  });
  html += '</tbody></table>';
  return html;
}

/* =================== 匯入按鈕與燈號整合（覆寫/擴充原有函式） =================== */
function updateCorrStatusIndicator(){
  const indicator = document.getElementById('corr_status_indicator');
  if(!indicator) return;
  // 有任何一個 map 有資料就視為已載入
  const has = (Object.keys(RHO_1Y||{}).length + Object.keys(RHO_3Y||{}).length + Object.keys(RHO_5Y||{}).length) > 0;
  if(has){
    indicator.textContent = '已載入';
    indicator.style.background = 'var(--pos)';
    indicator.style.borderColor = 'var(--pos)';
    indicator.style.color = 'var(--deep)';
  } else {
    indicator.textContent = '未載入';
    indicator.style.background = '#283556';
    indicator.style.borderColor = 'rgba(233,209,138,.35)';
    indicator.style.color = 'var(--gold-soft)';
  }
}

/* =================== Debug 區塊按鈕行為 =================== */
document.addEventListener('DOMContentLoaded',()=>{
  const hideBtn = document.getElementById('btnHideDebug');
  const refreshBtn = document.getElementById('btnRefreshDebug');
  if(hideBtn) hideBtn.addEventListener('click',()=>{
    const area = document.getElementById('corrDebugArea');
    if(area.style.display === 'none') { area.style.display='block'; hideBtn.textContent='隱藏'; }
    else { area.style.display='none'; hideBtn.textContent='顯示'; }
  });
  if(refreshBtn) refreshBtn.addEventListener('click',()=> renderDebugTables());
});

/* =================== 可選：對單一 pair 快速檢查（在 Console 可呼叫） =================== */
function debugCheckPair(a,b){
  console.log('normalize a,b ->', normalizeName(a), normalizeName(b));
  console.log('1Y', pickRhoMapByMode('1y')[ [normalizeName(a),normalizeName(b)].sort().join('|') ]);
  console.log('3Y', pickRhoMapByMode('3y')[ [normalizeName(a),normalizeName(b)].sort().join('|') ]);
  console.log('5Y', pickRhoMapByMode('5y')[ [normalizeName(a),normalizeName(b)].sort().join('|') ]);
}

/* =================== 初始化：若 localStorage 有舊資料嘗試載入（相容處理） =================== */
document.addEventListener('DOMContentLoaded',()=>{
  // 若舊有 LS_CORR_KEY，嘗試解析（此為舊版儲存格式，可能是 CSV）
  const txt = localStorage.getItem(LS_CORR_KEY) || '';
  if(txt && txt.trim()){
    // 嘗試簡易解析：若是我們 generateCsvFromRhoMaps 的格式（tag\tkey\tvalue）
    const lines = txt.trim().split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    let parsedSomething = false;
    lines.forEach(l=>{
      const parts = l.split(/\t/);
      if(parts.length===3 && (parts[0]==='1Y' || parts[0]==='3Y' || parts[0]==='5Y')){
        const tag = parts[0];
        const key = parts[1];
        const v = Number(parts[2]);
        if(tag==='1Y') RHO_1Y[key]=v;
        if(tag==='3Y') RHO_3Y[key]=v;
        if(tag==='5Y') RHO_5Y[key]=v;
        // cover set
        const pair = key.split('|');
        if(pair[0]) RHO_COVERED.add(pair[0]);
        if(pair[1]) RHO_COVERED.add(pair[1]);
        parsedSomething = true;
      }
    });
    if(parsedSomething) {
      updateCorrStatusIndicator();
      renderDebugTables();
    }
  }
});
</script>
</body>
</html>
